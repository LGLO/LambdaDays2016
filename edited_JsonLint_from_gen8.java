/*
  Source code is in UTF-8 encoding. The following symbols may appear, among others:
  α β γ δ ε ζ η θ ι κ λ μ ν ξ ο π ρ ς σ τ υ φ χ ψ ω « • ¦ » ∀ ∃ ∷ … → ← ﬁ ﬂ ƒ
  If you can't read this, you're out of luck.
  This code was generated with the frege compiler version 3.23.881-g0799a21 from
  /tmp/JsonLint.fr Do not edit this file! Instead, edit the source file and recompile.
*/


import frege.run8.Func;
import frege.run8.Lazy;
import frege.run8.Thunk;
import frege.run.Kind;
import frege.run.RunTM;
import frege.runtime.Meta;
import frege.runtime.Phantom.RealWorld;
import xxfrege.Prelude;
import xxfrege.control.Category;
import xxfrege.control.Semigroupoid;
import xxfrege.data.Bits;
import xxfrege.data.Iterators;
import xxfrege.data.JSON;
import xxfrege.data.List;
import xxfrege.data.MicroParsec;
import xxfrege.data.Monoid;
import xxfrege.java.IO;
import xxfrege.java.Lang;
import xxfrege.java.Util;
import xxfrege.java.util.Regex;
import xxfrege.lib.PP;
import xxfrege.prelude.Maybe;
import xxfrege.prelude.PreludeArrays;
import xxfrege.prelude.PreludeBase;
import xxfrege.prelude.PreludeIO;
import xxfrege.prelude.PreludeList;
import xxfrege.prelude.PreludeMonad;
import xxfrege.prelude.PreludeText;

@SuppressWarnings("unused")
@Meta.FregePackage(
        source = "/tmp/JsonLint.fr", time = 1455832164420L, jmajor = 9, jminor = -1,
        imps = {
                "frege.data.JSON", "frege.Prelude", "frege.prelude.PreludeArrays",
                "frege.prelude.PreludeBase", "frege.prelude.PreludeIO", "frege.prelude.PreludeList",
                "frege.prelude.PreludeMonad", "frege.prelude.PreludeText", "frege.java.util.Regex"
        },
        nmss = {
                "JSON", "Prelude", "PreludeArrays", "PreludeBase", "PreludeIO", "PreludeList",
                "PreludeMonad", "PreludeText", "Regexp"
        },
        symas = {
                @Meta.SymA(
                        offset = 69, name = @Meta.QName(kind = 0, pack = "JsonLint", base = "Validate"), vars = {},
                        typ = 1, kind = 1
                ),
                @Meta.SymA(
                        offset = 46, name = @Meta.QName(kind = 0, pack = "JsonLint", base = "ErrorStr"), vars = {},
                        typ = 0, kind = 1
                )
        },
        symcs = {}, symis = {}, symts = {},
        symvs = {
                @Meta.SymV(
                        offset = 393, name = @Meta.QName(pack = "JsonLint", base = "validateJson"), stri = "s(u)",
                        sig = 1, depth = 1, rkind = 49
                ),
                @Meta.SymV(
                        offset = 525, name = @Meta.QName(pack = "JsonLint", base = "valid"), stri = "s",
                        sig = 0, depth = 0, rkind = 49
                ),
                @Meta.SymV(
                        offset = 161, name = @Meta.QName(pack = "JsonLint", base = "parseToValue"), stri = "s(u)",
                        sig = 2, depth = 1, rkind = 49
                ),
                @Meta.SymV(
                        offset = 597, name = @Meta.QName(pack = "JsonLint", base = "main"), stri = "s(u)",
                        sig = 4, depth = 1, rkind = 49
                ),
                @Meta.SymV(
                        offset = 560, name = @Meta.QName(pack = "JsonLint", base = "invalid"), stri = "s",
                        sig = 0, depth = 0, rkind = 49
                )
        },
        symls = {},
        taus = {
                @Meta.Tau(
                        kind = 2, suba = 0,
                        tcon = {@Meta.QName(kind = 0, pack = "frege.prelude.PreludeBase", base = "StringJ")}
                ),
                @Meta.Tau(
                        kind = 2, suba = 0, tcon = {@Meta.QName(kind = 0, pack = "frege.prelude.PreludeBase", base = "Char")}
                ),
                @Meta.Tau(kind = 0, suba = 0, subb = 1),
                @Meta.Tau(
                        kind = 2, suba = 0,
                        tcon = {@Meta.QName(kind = 0, pack = "frege.prelude.PreludeBase", base = "Either")}
                ),
                @Meta.Tau(kind = 0, suba = 3, subb = 2), @Meta.Tau(kind = 0, suba = 4, subb = 2),
                @Meta.Tau(kind = 2, suba = 0, tcon = {@Meta.QName(kind = 0, pack = "frege.data.JSON", base = "Value")}),
                @Meta.Tau(kind = 0, suba = 4, subb = 6),
                @Meta.Tau(
                        kind = 2, suba = 0, tcon = {@Meta.QName(kind = 0, pack = "frege.prelude.PreludeBase", base = "[]")}
                ),
                @Meta.Tau(kind = 0, suba = 8, subb = 2),
                @Meta.Tau(
                        kind = 2, suba = 0, tcon = {@Meta.QName(kind = 0, pack = "frege.prelude.PreludeBase", base = "ST")}
                ),
                @Meta.Tau(
                        kind = 2, suba = 0,
                        tcon = {@Meta.QName(kind = 0, pack = "frege.prelude.PreludeBase", base = "RealWorld")}
                ),
                @Meta.Tau(kind = 0, suba = 10, subb = 11),
                @Meta.Tau(
                        kind = 2, suba = 0, tcon = {@Meta.QName(kind = 0, pack = "frege.prelude.PreludeBase", base = "()")}
                ),
                @Meta.Tau(kind = 0, suba = 12, subb = 13)
        },
        rhos = {
                @Meta.Rho(rhofun = false, rhotau = 2), @Meta.Rho(rhofun = false, rhotau = 5),
                @Meta.Rho(sigma = 0, rhotau = 1), @Meta.Rho(rhofun = false, rhotau = 7),
                @Meta.Rho(sigma = 0, rhotau = 3), @Meta.Rho(rhofun = false, rhotau = 9),
                @Meta.Rho(rhofun = false, rhotau = 14), @Meta.Rho(sigma = 3, rhotau = 6)
        },
        sigmas = {
                @Meta.Sigma(rho = 0), @Meta.Sigma(rho = 2), @Meta.Sigma(rho = 4), @Meta.Sigma(rho = 5),
                @Meta.Sigma(rho = 7)
        },
        exprs = {@Meta.Expr()}, kinds = {@Meta.Kind(kind = 0), @Meta.Kind(kind = 2)}
)

final public class xxJsonLint {

    final public static String valid = "[1,\"ala\", {\"a\":123}]";

    final public static PreludeBase.TEither<String, JSON.TValue> parseToValue(
            final Lazy<String> arg$1) 
    {
        return PreludeBase.TEither.<String, JSON.TValue>coerce(
                JSON.IFromJSON_Value.it.<PreludeBase.TEither<String, ?>>ƒparseJSON(
                        PreludeMonad.IMonadFail_Either.it, arg$1
                )
        );
    }

    final public static PreludeBase.TEither<String, String> validateJson(final Lazy<String> arg$1)
    {
        final PreludeBase.TEither<String, JSON.TValue> $19365 = xxJsonLint.parseToValue(arg$1);
        final PreludeBase.TEither.DLeft<String, JSON.TValue> $19368 = $19365.isLeft();
        if ($19368 != null) {
            return PreludeBase.TEither.DLeft.<String, String>mk(
                    $19368.mem1
            );
        }
        final PreludeBase.TEither.DRight<String, JSON.TValue> $19367 = $19365.isRight();
        assert $19367 != null;
        return PreludeBase.TEither.DRight.<String, String>mk(
                Thunk.<String>shared((Lazy<String>) (() -> JSON.IShow_Value.show($19367.mem1)))
        );
    }

    // function `invalid`  s  {RValue, RSimple, RSafeTC}
// String
// "[1,\"ala\", {\"a\":123]"
    final public static String invalid = "[1,\"ala\", {\"a\":123]";

    // function `main`  s(u)  {RValue, RSimple, RSafeTC}
// [String] → IO ()
    final public static Func.U<RealWorld, Short> $main(final Lazy<PreludeBase.TList<String>> arg$1) {
        // return Func.U<RealWorld, Short>  >> (println (validateJson valid)) (println (validateJson invalid))
        // Bind {IO (), Func.U<RealWorld, Short>, PreludeMonad.IMonad_ST.<RealWorld, Short, Short>$gt$gt(Prelude.<PreludeBase.TEither<String, String>>println(new PreludeText.IShow_Either<String, String>(PreludeText.IShow_String.it, PreludeText.IShow_String.it), xxJsonLint.validateJson(Thunk.<String>lazy(xxJsonLint.valid))), Thunk.<Func.U<RealWorld, Short>>shared((Lazy<Func.U<RealWorld, Short>>)(() -> Prelude.<PreludeBase.TEither<String, String>>println(new PreludeText.IShow_Either<String, String>(PreludeText.IShow_String.it, PreludeText.IShow_String.it), xxJsonLint.validateJson(Thunk.<String>lazy(xxJsonLint.invalid))))))}
        return PreludeMonad.IMonad_ST.<RealWorld, Short, Short>$gt$gt(
                Prelude.<PreludeBase.TEither<String, String>>println(
                        new PreludeText.IShow_Either<String, String>(
                                PreludeText.IShow_String.it, PreludeText.IShow_String.it
                        ),
                        xxJsonLint.validateJson(Thunk.<String>lazy(xxJsonLint.valid))
                ),
                Thunk.<Func.U<RealWorld, Short>>shared(
                        (Lazy<Func.U<RealWorld, Short>>) (() -> Prelude.<
                                PreludeBase.TEither<String, String>
                                >println(
                                new PreludeText.IShow_Either<String, String>(
                                        PreludeText.IShow_String.it, PreludeText.IShow_String.it
                                ),
                                xxJsonLint.validateJson(Thunk.<String>lazy(xxJsonLint.invalid))
                        ))
                )
        );
    }

    public static void main(final java.lang.String[] argv) {

        PreludeBase.TST.<Short>performUnsafe($main
                (Thunk.lazy(PreludeArrays.IListSource_JArray.<String>toList(argv)))
        ).call();

    }
}
